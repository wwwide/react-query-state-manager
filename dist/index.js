var m=(t,e,r)=>new Promise((o,u)=>{var i=a=>{try{l(r.next(a))}catch(n){u(n)}},s=a=>{try{l(r.throw(a))}catch(n){u(n)}},l=a=>a.done?o(a.value):Promise.resolve(a.value).then(i,s);l((r=r.apply(t,e)).next())});import{useQueryClient as A}from"react-query";import{useCallback as c}from"react";var y=(t,e)=>{t.removeQueries(e)},f=t=>{t.removeQueries()},Q=t=>{let e=c(o=>y(t,o),[y]),r=c(()=>f(t),[f]);return{remove:e,removeAll:r}};import{useCallback as U}from"react";var p=(t,e,r)=>t.setQueryData(e,r),d=t=>({set:U((r,o)=>p(t,r,o),[p])});import{useCallback as P}from"react";var v=(t,e)=>t.getQueryData(e),D=t=>({get:P(r=>v(t,r),[v])});import{useCallback as T}from"react";import{useQuery as M,useQueryClient as H}from"react-query";var S=(t,e,r)=>{let o=H(),{data:u,isFetching:i,isFetched:s,isError:l,isIdle:a,isSuccess:n,status:K,error:g}=M(t,e,r),V=T(()=>{y(o,t)},[y,o]);return{data:u,isFetching:i,isFetched:s,isError:l,isIdle:a,isSuccess:n,status:K,error:g,cleanUp:V}},x=()=>({use:T((e,r,o)=>S(e,r,o),[S])});import{useCallback as R}from"react";var C=(t,e)=>t.invalidateQueries(e),k=t=>({invalidate:R(r=>C(t,r),[C])});var te=()=>{let t=A(),{remove:e,removeAll:r}=Q(t),{set:o}=d(t),{get:u}=D(t),{invalidate:i}=k(t),{use:s}=x();return{__client__:t,get:u,set:o,invalidate:i,remove:e,removeAll:r,use:s}};import{useCallback as I}from"react";import{useMutation as b}from"react-query";var ne=(t,e)=>{let{mutateAsync:r,isError:o,isSuccess:u,isLoading:i,status:s}=b(a=>t(a)),l=I(a=>m(void 0,null,function*(){try{e!=null&&e.onBefore&&(yield e.onBefore(a));let n=yield r(a);return e!=null&&e.onSuccess&&(yield e.onSuccess(a,n)),n}catch(n){throw e!=null&&e.onError&&e.onError(n),n}finally{e!=null&&e.onFinally&&e.onFinally()}}),[e]);return{mutateAsync:r,routine:l,isError:o,isSuccess:u,isLoading:i,status:s}};export{ne as useMutationManager,te as useStateManager};
